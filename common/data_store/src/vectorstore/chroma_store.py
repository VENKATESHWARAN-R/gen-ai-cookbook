"""
ChromaVectorStore class for interacting with ChromaDB.
"""

import chromadb
from chromadb import EmbeddingFunction
from chromadb.config import Settings
from chromadb.utils import embedding_functions
from langchain_core.documents import Document
from typing import List, Dict, Any
import uuid
import logging

from data_store.src.utils import config
from data_store.src.embeddings.embedding_service import SentenceTransformerEmbeddings

logger = logging.getLogger(__name__)

# For stopping the ChromaDB client sending telemetry data
client = chromadb.Client(Settings(anonymized_telemetry=False))

class CustomChromaEmbedder(embedding_functions.EmbeddingFunction):
    def __init__(self, provider: SentenceTransformerEmbeddings):
        self.provider = provider

    def __call__(self, input: List[str]) -> List[List[float]]:
        return self.provider.embed_documents(input)


class ChromaVectorStore:
    def __init__(
        self,
        path: str = config.CHROMA_DB_PATH,
        collection_name: str = config.CHROMA_COLLECTION_NAME,
        embedding_provider: SentenceTransformerEmbeddings = None,  # Pass instance
    ):
        """
        Initializes the ChromaDB client and collection.

        Args:
            path: Path to the directory where ChromaDB data will be persisted.
            collection_name: Name of the collection within ChromaDB.
            embedding_provider: An instance of SentenceTransformerEmbeddings.
        """
        logger.info(f"Initializing ChromaDB client at path: {path}")
        self.client = chromadb.PersistentClient(path=path)

        self.embedding_provider = (
            embedding_provider or SentenceTransformerEmbeddings()
        )  # Use passed or create new

        # Wrap the custom embedding function for ChromaDB
        # self.chroma_embedding_function = embedding_functions.SentenceTransformerEmbeddingFunction(
        #      model_name=self.embedding_provider.model.config.name_or_path # Get name from loaded model
        # )
        self.chroma_embedding_function = CustomChromaEmbedder(self.embedding_provider)

        logger.info(f"Getting or creating ChromaDB collection: {collection_name}")
        try:
            self.collection = self.client.get_or_create_collection(
                name=collection_name,
                embedding_function=self.chroma_embedding_function,
                # metadata={"hnsw:space": "cosine"}
            )
            logger.info(f"Collection '{collection_name}' ready.")
        except Exception as e:
            logger.error(
                f"Failed to get or create Chroma collection '{collection_name}': {e}"
            )
            raise

    def add_documents(self, documents: List[Document]):
        """
        Adds documents (chunks) to the ChromaDB collection.
        Embeddings are generated by the function provided during collection creation.

        Args:
            documents: A list of LangChain Document objects (chunks).
                       Assumes page_content contains the text to be embedded.
        """
        if not documents:
            logger.warning("No documents provided to add.")
            return

        logger.info(
            f"Adding {len(documents)} documents to collection '{self.collection.name}'..."
        )

        ids = [str(uuid.uuid4()) for _ in documents]
        texts = [doc.page_content for doc in documents]
        # Ensure metadata values are Chroma-compatible types (str, int, float, bool)
        metadatas = [
            {
                k: str(v) if not isinstance(v, (str, int, float, bool)) else v
                for k, v in doc.metadata.items()
            }
            for doc in documents
        ]

        try:
            # ChromaDB's add method will use the collection's embedding function
            self.collection.add(ids=ids, documents=texts, metadatas=metadatas)
            logger.info(f"Successfully added {len(documents)} documents.")
        except Exception as e:
            logger.error(f"Failed to add documents to Chroma collection: {e}")

    def search(self, query: str, k: int = 5) -> List[Dict[str, Any]]:
        """
        Performs a similarity search in the ChromaDB collection.

        Args:
            query: The search query string.
            k: The number of top results to retrieve.

        Returns:
            A list of dictionaries, each containing 'document', 'metadata', and 'distance'.
            Returns empty list on error or no results.
        """
        logger.info(
            f"Performing search in collection '{self.collection.name}' for query: '{query[:50]}...' (k={k})"
        )
        try:
            # The query text is automatically embedded by the collection's embedding function
            results = self.collection.query(
                query_texts=[query],
                n_results=k,
                include=[
                    "documents",
                    "metadatas",
                    "distances",
                ],  # Request desired fields
            )

            # Structure the results
            search_results = []
            if results and results.get("ids") and results["ids"][0]:
                for i in range(len(results["ids"][0])):
                    search_results.append(
                        {
                            "id": results["ids"][0][i],
                            "document": (
                                results["documents"][0][i]
                                if results.get("documents")
                                else None
                            ),
                            "metadata": (
                                results["metadatas"][0][i]
                                if results.get("metadatas")
                                else None
                            ),
                            "distance": (
                                results["distances"][0][i]
                                if results.get("distances")
                                else None
                            ),
                            "similarity": (
                                1.0 - results["distances"][0][i]
                                if results.get("distances")
                                else None
                            ),
                        }
                    )
                logger.info(f"Found {len(search_results)} results.")
            else:
                logger.info("No results found.")

            return search_results

        except Exception as e:
            logger.error(f"Error during search in Chroma collection: {e}")
            return []

    def get_collection_count(self) -> int:
        """Returns the number of items in the collection."""
        try:
            return self.collection.count()
        except Exception as e:
            logger.error(f"Error getting collection count: {e}")
            return 0

    def clear_collection(self):
        """Deletes all items from the collection."""
        logger.warning(
            f"Attempting to clear all items from collection: {self.collection.name}"
        )
        try:
            # This is inefficient for large collections. A better way is delete/recreate.
            count = self.collection.count()
            if count > 0:
                ids_to_delete = self.collection.get(limit=count)[
                    "ids"
                ]  # Get all IDs (might be slow)
                if ids_to_delete:
                    self.collection.delete(ids=ids_to_delete)
                    logger.info(
                        f"Cleared {len(ids_to_delete)} items from collection '{self.collection.name}'."
                    )
                else:
                    logger.info(
                        f"Collection '{self.collection.name}' was already empty or failed to retrieve IDs."
                    )
            else:
                logger.info(f"Collection '{self.collection.name}' is already empty.")
        except Exception as e:
            logger.error(f"Error clearing collection '{self.collection.name}': {e}")
